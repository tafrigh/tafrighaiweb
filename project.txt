---

`src\pages\api\transcribe.ts`:
```
import type { APIRoute } from 'astro';
import { Client, handle_file } from '@gradio/client';

export const POST: APIRoute = async ({ request }) => {
  try {
    if (!import.meta.env.PUBLIC_HUGGINGFACE_TOKEN) {
      return new Response(JSON.stringify({ error: 'Hugging Face token not found' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }

    const formData = await request.formData();
    const audioFile = formData.get('audio') as File;
    const model = formData.get('model') as string || 'standard'; // Get the model, default to 'standard'

    if (!audioFile) {
      return new Response(JSON.stringify({ error: 'No audio file provided' }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }
    const audioBlob = new Blob([await audioFile.arrayBuffer()], { type: audioFile.type });

    const spaceName = model === 'turbo' ? "hf-audio/whisper-large-v3-turbo" : "hf-audio/whisper-large-v3"; // Choose the space
    const app = await Client.connect(spaceName, {
      hf_token: import.meta.env.PUBLIC_HUGGINGFACE_TOKEN,
    });

    const result = await app.predict('/predict', [handle_file(audioBlob), 'transcribe']);

    if (result && result.data && Array.isArray(result.data) && result.data.length > 0) {
      const transcription = result.data[0];
      if (typeof transcription === 'string') {
        return new Response(JSON.stringify({ transcription }), { status: 200, headers: { 'Content-Type': 'application/json' } });
      } else {
        return new Response(JSON.stringify({ error: 'transcription is not a string' }), { status: 500 });
      }
    } else {
      return new Response(JSON.stringify({ error: 'result is invalid' }), { status: 500 });
    }
  } catch (error) {
     // ... (same error handling)
     let errorMessage = 'Transcription failed';
    let errorDetails = 'Unknown error';

    if (error instanceof Error) {
      errorDetails = error.message;
    } else if (typeof error === 'string') {
      errorDetails = error;
    } else if (error && typeof error === 'object' && 'message' in error) {
        // Check if the object has a 'message' property before accessing it
        const errObj = error as { message?: unknown }; // Type assertion
        if (typeof errObj.message === 'string') {
            errorDetails = errObj.message;
        }

    }


    return new Response(JSON.stringify({ error: errorMessage, details: errorDetails }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
};
```

---

`src\pages\index.astro`:
```
---
import AudioTranscriber from '../components/AudioTranscriber.astro';
import Layout from '../layouts/Layout.astro';
---

<Layout>
  <h1>Tafreegh.ai</h1>
  <AudioTranscriber />
</Layout>
```

---

`.env`:
```
e
```

---

`src\pages\api\transcribe-yt.ts`:
```
import type { APIRoute } from 'astro';
import { Client, handle_file } from '@gradio/client';

export const POST: APIRoute = async ({ request }) => {
  try {
    if (!import.meta.env.PUBLIC_HUGGINGFACE_TOKEN) {
      return new Response(JSON.stringify({ error: 'Hugging Face token not found' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }

    const formData = await request.formData();
    const ytUrl = formData.get('yt_url') as string | null;
    const model = formData.get('model') as string || 'standard'; // Get the model

    if (!ytUrl) {
      return new Response(JSON.stringify({ error: 'No YouTube URL provided' }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }

    const spaceName = model === 'turbo' ? "hf-audio/whisper-large-v3-turbo" : "hf-audio/whisper-large-v3"; // Choose the space
    const app = await Client.connect(spaceName, {
      hf_token: import.meta.env.PUBLIC_HUGGINGFACE_TOKEN,
    });

    const result = await app.predict('/predict_2', [ytUrl, 'transcribe']);

    if (result && result.data && Array.isArray(result.data) && result.data.length === 2) {
      const htmlContent = result.data[0];
      const transcription = result.data[1];

      if (typeof transcription === 'string' && typeof htmlContent === 'string') {
        return new Response(JSON.stringify({ html: htmlContent, transcription }), { status: 200, headers: { 'Content-Type': 'application/json' } });
      } else {
        return new Response(JSON.stringify({ error: 'html or transcription is not a string' }), { status: 500 });
      }
    } else {
      return new Response(JSON.stringify({ error: 'result is invalid' }), { status: 500 });
    }

  } catch (error) {
    // ... (same error handling)
    let errorMessage = 'Transcription failed';
    let errorDetails = 'Unknown error';

    if (error instanceof Error) {
      errorDetails = error.message;
    } else if (typeof error === 'string') {
      errorDetails = error;
    } else if (error && typeof error === 'object' && 'message' in error) {
        // Check if the object has a 'message' property before accessing it
        const errObj = error as { message?: unknown }; // Type assertion
        if (typeof errObj.message === 'string') {
            errorDetails = errObj.message;
        }

    }


    return new Response(JSON.stringify({ error: errorMessage, details: errorDetails }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
};
```

---

`src\styles\global.css`:
```
*,
*::before,
*::after {
    box-sizing: border-box;
    margin: 0;
}

body {
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
    font-family: "Open Sans Variable", sans-serif;
    font-size: 1rem;
    background-color: var(--md-sys-color-background);
    color: var(--md-sys-color-on-background);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 1em;
    position: relative;
    transition: background-color 0.3s ease, color 0.3s ease;
    gap: 1em;
}

.col{
    display: flex;
    flex-direction: column;
    align-items: center;
}
```

---

`src\components\AudioTranscriber.astro`:
```
---
import { Icon } from "astro-icon/components";
---

<div class="main col">
  <div class="file col">
    <label for="audio-input" style="display: none;">Upload Audio:</label>
    <input
      type="file"
      id="audio-input"
      accept="audio/*"
      style="display: none;"
    />
    <md-filled-tonal-button id="file-select-button">
      <Icon slot="icon" name="upload" />
      <span id="file-button-label">Choose File</span>
    </md-filled-tonal-button>
    <div id="file-name-display"></div>
  </div>
  <style>
    .file {
      gap: 0.5em;
    }
  </style>
  <div>
    <md-outlined-text-field
      type="text"
      id="youtube-input"
      placeholder="Enter YouTube URL"
    >
      <Icon name="youtube" slot="trailing-icon" />
    </md-outlined-text-field>
  </div>
  <div>
    <div>
      <md-outlined-select id="model-select" label="Choose Model">
        <Icon name="rocket1" slot="leading-icon" />
        <md-select-option selected value="standard">
          <Icon name="rocket1" slot="start" />
          <div slot="headline">Standard</div>
        </md-select-option>
        <md-select-option value="turbo">
          <Icon name="rocket" slot="start" />
          <div slot="headline">Turbo</div>
        </md-select-option>
      </md-outlined-select>
    </div>
  </div>
  <md-filled-button raised id="transcribe-button"
    ><Icon slot="icon" name="transcribe" /> Tafrigh</md-filled-button
  >
  <div id="transcription-output"></div>
</div>

<script>
  import "material/button/filled-button";
  import "material/button/elevated-button";
  import "material/textfield/outlined-text-field";
  import "material/select/outlined-select";
  import "material/select/select-option";
  import "material/button/filled-tonal-button";
  const audioInput = document.getElementById("audio-input") as HTMLInputElement;
  const youtubeInput = document.getElementById(
    "youtube-input",
  ) as HTMLInputElement;
  const modelSelect = document.getElementById(
    "model-select",
  ) as HTMLSelectElement;
  const transcribeButton = document.getElementById(
    "transcribe-button",
  ) as HTMLButtonElement;
  const transcriptionOutput = document.getElementById(
    "transcription-output",
  ) as HTMLDivElement;
  const fileSelectButton = document.getElementById(
    "file-select-button",
  ) as HTMLButtonElement;
  const fileNameDisplay = document.getElementById(
    "file-name-display",
  ) as HTMLDivElement;
  const fileButtonLabel = document.getElementById(
    "file-button-label",
  ) as HTMLSpanElement;

  fileSelectButton.addEventListener("click", () => {
    audioInput.click();
  });

  audioInput.addEventListener("change", () => {
    if (audioInput.files && audioInput.files.length > 0) {
      fileNameDisplay.textContent = audioInput.files[0].name;
      fileButtonLabel.textContent = "Change File";
    } else {
      fileNameDisplay.textContent = "";
      fileButtonLabel.textContent = "Choose File";
    }
  });

  transcribeButton.addEventListener("click", async () => {
    transcriptionOutput.textContent = "Transcribing...";

    let formData: FormData | null = null;
    let endpoint = "/api/transcribe";
    let isYouTube = false;
    const selectedModel = modelSelect.value;

    if (audioInput.files && audioInput.files.length > 0) {
      formData = new FormData();
      formData.append("audio", audioInput.files[0]);
      formData.append("model", selectedModel);
      endpoint = "/api/transcribe";
    } else if (youtubeInput.value.trim() !== "") {
      formData = new FormData();
      formData.append("yt_url", youtubeInput.value.trim());
      formData.append("model", selectedModel);
      endpoint = "/api/transcribe-yt";
      isYouTube = true;
    } else {
      transcriptionOutput.textContent =
        "Please select an audio file or enter a YouTube URL.";
      return;
    }

    try {
      const response = await fetch(endpoint, {
        method: "POST",
        body: formData,
      });

      if (response.ok) {
        const data = await response.json();
        if (isYouTube) {
          if (data.transcription) {
            transcriptionOutput.innerHTML = `<div>${data.html || ""}</div><div>Transcription: ${data.transcription}</div>`;
          } else {
            transcriptionOutput.textContent = `Error: ${data.error || "Unknown error"}`;
          }
        } else {
          if (data.transcription) {
            transcriptionOutput.textContent = `Transcription: ${data.transcription}`;
          } else {
            transcriptionOutput.textContent = `Error: ${data.error || "Unknown error"}`;
          }
        }
      } else {
        transcriptionOutput.textContent = `Error: ${response.status} - ${response.statusText}`;
      }
    } catch (error) {
      console.error("Error during transcription:", error);
      transcriptionOutput.textContent = `Error: ${error}`;
    }
  });
</script>

<style>
  .main {
    gap: 1em;
  }
</style>

```

---

`src\layouts\Layout.astro`:
```
---
import '../styles/global.css';
---

<!DOCTYPE html>
<html lang="en">
        <head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width" />
                <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
                <meta name="generator" content={Astro.generator} />
                <title>Astro Basics</title>
        </head>
        <body>
                <slot />
        </body>
</html>

```

---

`astro.config.mjs`:
```
// @ts-check
import { defineConfig } from 'astro/config';

import netlify from '@astrojs/netlify';

import icon from 'astro-icon';

// https://astro.build/config
export default defineConfig({
  output: 'server',
  adapter: netlify(),
  integrations: [icon()]
});
```

---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```

---